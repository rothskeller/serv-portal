package util

import (
	"fmt"
	"net/http"
	"path"
	"runtime/debug"
	"strconv"

	"sunnyvaleserv.org/portal/model"
	"sunnyvaleserv.org/portal/store"
	"sunnyvaleserv.org/portal/store/authz"
	"sunnyvaleserv.org/portal/util/log"
)

// RunRequest handles an incoming HTTP request, described by the Go standard
// library http.Request and http.ResponseWriter parameters.  It generates a
// Request structure with the request details, passes it to the specified
// RequestHandler, and logs the result.
//
// If the RequestHandler did not emit a response, RunRequest will generate one
// and emit it, as follows:
//   - If the handler returned nil, the generated response is a 204 No Content.
//   - If the handler returned an error that has an HTTPStatusCode() method,
//     such as an error generated by calling HTTPError(), the generated response
//     uses the status code returned by that method, and the error message from
//     the error.
//   - If the handler returned an error that does not have an HTTPStatusCode()
//     method, the generated response is a 400 Bad Request, with the error
//     message from the error.
//   - If the handler panicked, the generated response is a 500 Internal Server
//     Error.
func RunRequest(w http.ResponseWriter, r *http.Request, handler RequestHandler) {
	var (
		request *Request
		err     error
	)
	request = &Request{
		Request: r,
		Response: Response{
			ResponseWriter: w,
		},
		Path: path.Clean("/" + r.URL.Path),
	}
	request.LogEntry = log.New(request.Method, request.Path)
	defer func() {
		var panicked interface{}

		if panicked = recover(); panicked != nil {
			request.LogEntry.Error = fmt.Sprintf("PANIC: %v", panicked)
			request.LogEntry.Status = http.StatusInternalServerError
			request.LogEntry.Stack = debug.Stack()
			err = HTTPError(http.StatusInternalServerError, "Internal Server Error")
		} else if hsce, ok := err.(hasStatusCode); ok {
			request.LogEntry.Error = err.Error()
			request.LogEntry.Status = hsce.StatusCode()
		} else if err != nil {
			request.LogEntry.Error = err.Error()
			request.LogEntry.Status = http.StatusBadRequest
		} else if request.StatusCode != 0 {
			request.LogEntry.Status = request.StatusCode
		} else {
			request.LogEntry.Status = http.StatusNoContent
		}
		if request.StatusCode == 0 {
			if request.LogEntry.Status == http.StatusNoContent {
				request.WriteHeader(http.StatusNoContent)
			} else {
				http.Error(&request.Response, err.Error(), request.LogEntry.Status)
			}
		}
		if f, ok := request.Response.ResponseWriter.(http.Flusher); ok {
			f.Flush()
		}
		if request.Session != nil {
			request.LogEntry.Session = string(request.Session.Token)
		}
		request.LogEntry.Params = request.Form
		request.LogEntry.Log()
	}()
	err = handler(request)
}

// A Request represents an in-progress web request.  It contains the request
// data, the response data, the caller's session data if any, and similar
// tracking data.
type Request struct {
	*http.Request
	Response
	Session  *model.Session
	Person   *model.Person
	Auth     *authz.Authorizer
	Path     string
	Tx       *store.Tx
	LogEntry *log.Entry
}

// Header and Write on Request resolve the ambiguities between http.Request
// and http.ResponseWriter, in favor of the latter.  This allows Request to be
// used in the context of an http.ResponseWriter, such as in calls to
// http.Error.
func (r *Request) Header() http.Header           { return r.Response.Header() }
func (r *Request) Write(buf []byte) (int, error) { return r.Response.Write(buf) }

// Response is an implementation of http.ResponseWriter that records the status
// code sent in the response.
type Response struct {
	http.ResponseWriter
	StatusCode int
}

func (r *Response) Write(buf []byte) (int, error) {
	if r.StatusCode == 0 {
		r.StatusCode = http.StatusOK
	}
	return r.ResponseWriter.Write(buf)
}

// WriteHeader implements http.ResponseWriter.
func (r *Response) WriteHeader(statusCode int) {
	r.StatusCode = statusCode
	r.ResponseWriter.WriteHeader(statusCode)
}

// A RequestHandler is a function that takes a Request and returns an error.
// See RunRequest for how this is used.
type RequestHandler func(*Request) error

// HTTPError returns an error containing an HTTP status code and a message.
// This is a common return from a RequestHandler, as the RunRequest function can
// use it to generate an error response to the caller.
func HTTPError(statusCode int, message string) error {
	return &httpError{code: statusCode, msg: message}
}

type httpError struct {
	msg  string
	code int
}

func (he httpError) Error() string   { return he.msg }
func (he httpError) StatusCode() int { return he.code }

type hasStatusCode interface {
	StatusCode() int
}

// NotFound is an HTTPError for a URL that does not exist.
var NotFound = HTTPError(http.StatusNotFound, "404 Not Found")

// ParseID parses a string as an integer, returning -1 if it's not valid.
func ParseID(s string) int {
	if val, err := strconv.Atoi(s); err == nil {
		return val
	}
	return -1
}

// KeepDigits is a function to be passed to strings.Map, which will keep only
// the digits from a string and discard all other characters.
func KeepDigits(r rune) rune {
	if r >= '0' && r <= '9' {
		return r
	}
	return -1
}
